# sv39复习


### 3级页表结构

| Page Directory | Page Directory | Page Table     | Offset within Page |
|:--------------:|:--------------:|:--------------:|:------------------:|
| Index 1        | Index 2        |                |                    |
| PDX1(la)       | PDX0(la)       | PTX(la)        | PGOFF(la)          |
|                |                |                |                    |
| <-------------------PPN(la)------------------->                    |


### 虚拟地址结构

|  VPN[2]  |  VPN[1]  |  VPN[0]  |  PGOFF  |
|:--------:|:--------:|:--------:|:-------:|
|   9 bit  |   9 bit  |   9 bit  | 12 bit  |


### 物理地址结构

|  PPN[2]  |  PPN[1]  |  PPN[0]  |  PGOFF  |
|:--------:|:--------:|:--------:|:-------:|
|  26 bit  |   9 bit  |   9 bit  | 12 bit  |


### 页表项结构

|  PPN[2]  |  PPN[1]  |  PPN[0]  | Reserved | D | A | G | U | X | W | R | V |
|:--------:|:--------:|:--------:|:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  26 bit  |   9 bit  |   9 bit  |   2 bit  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

# kern/mm/mmu.h内容
下面结合源码逐条解释：

#### 地址分解与宏
sv39 的 64 位虚拟地址低 39 位参与页表（9+9+9+12），对应 `PDX1`(VPN[2])、`PDX0`(VPN[1])、`PTX`(VPN[0])、`PGOFF`。`mmu.h` 中：

- `#define PDX1(la) ((((uintptr_t)(la)) >> PDX1SHIFT) & 0x1FF)` 取最高层 9bit；
- `#define PDX0(la) ((((uintptr_t)(la)) >> PDX0SHIFT) & 0x1FF)` 取中间层 9bit；
- `#define PTX(la)  ((((uintptr_t)(la)) >> PTXSHIFT)  & 0x1FF)` 取最低层页表索引 9bit；
- `#define PGOFF(la) (((uintptr_t)(la)) & 0xFFF)` 页内偏移 12bit；
- `#define PPN(la)   (((uintptr_t)(la)) >> PTXSHIFT)` 去掉页内偏移后得到线性地址对应的“页号”字段（含所有 VPN bits 合起来）。一共**44**位

位移常量：

- `PTXSHIFT = 12` 页内偏移长度；
- `PDX0SHIFT = 21` = 12 + 9；
- `PDX1SHIFT = 30` = 12 + 9 + 9。

构造地址：`PGADDR(d1,d0,t,o)` 把三个层级索引与页内偏移重新拼成线性地址。
```cpp
#define PGADDR(d1, d0, t, o) ((uintptr_t)((d1) << PDX1SHIFT |(d0) << PDX0SHIFT | (t) << PTXSHIFT | (o)))
```
一个一个左移相应的位数，然后按位或拼接起来

#### 页表项地址抽取
```cpp
#define PTE_ADDR(pte)   (((uintptr_t)(pte) & ~0x3FF) << (PTXSHIFT - PTE_PPN_SHIFT))
#define PDE_ADDR(pde)   PTE_ADDR(pde)
```
- `PTE_ADDR(pte)` 清掉低 10 位标志位（`& ~0x3FF`），再左移把 PPN 对齐，得到物理页基址。把Reserved和DAG什么的全部删掉，然后左移12位**凑出了12位**的页内偏移。
- `PDE_ADDR(pde)` 与 `PTE_ADDR` 相同，用于目录项。

`PTE_PPN_SHIFT = 10` 表示 PTE 中低 10 位是标志，后面开始为 PPN。

在该页表示一个物理页的时候就有用。

#### 结构和大小常量
- `NPDEENTRY = 512`，`NPTEENTRY = 512`：每层 512 项（9bit）。
- `PGSIZE = 4096`，`PGSHIFT = 12`：页大小与其 log2。
- `PTSIZE = PGSIZE * NPTEENTRY = 2MB`：一个二级页表（最低层）映射的总字节数。
- `PTSHIFT = 21`：log2(2MB)。

#### 权限与标志位（对应 RISC-V PTE）
| 宏 | 值 | 说明 |
|----|----|------|
| `PTE_V` | 0x001 | 有效（Valid）|
| `PTE_R` | 0x002 | 可读 |
| `PTE_W` | 0x004 | 可写 |
| `PTE_X` | 0x008 | 可执行 |
| `PTE_U` | 0x010 | 用户态可访问 |
| `PTE_G` | 0x020 | 全局页（不清 TLB）|
| `PTE_A` | 0x040 | 已访问（硬件或软件置位）|
| `PTE_D` | 0x080 | 已修改（脏页）|
| `PTE_SOFT` | 0x300 | 软件保留位（实现可自定义）|

组合宏：
```cpp
#define PAGE_TABLE_DIR (PTE_V)
#define READ_ONLY (PTE_R | PTE_V)   // 只读
#define READ_WRITE (PTE_R | PTE_W | PTE_V)  //读写
#define EXEC_ONLY (PTE_X | PTE_V)   //只能执行
#define READ_EXEC (PTE_R | PTE_X | PTE_V)   //读 + 执行
#define READ_WRITE_EXEC (PTE_R | PTE_W | PTE_X | PTE_V) // 读写执行
```
- `PAGE_TABLE_DIR`：仅有效位，用来指示该条目指向下一层页表（一般还需要检查其余位是否为 0 来判定非叶子）。
- `READ_ONLY / READ_WRITE / EXEC_ONLY / READ_EXEC / READ_WRITE_EXEC`：常用权限集合，方便建立段/页映射。
- `PTE_USER`：用户页的常用组合（读写执行 + 用户 + 有效）。

#### 关于注释中 Sv32 的提醒
文件顶部和中间的 ASCII 注释仍显示 10/10/12 结构以及 “Sv32 page table entry”，这是旧的双级页表（Sv32）格式。当前宏与常量（512 项、9bit 索引、3 级）对应的是 Sv39。应注意该注释尚未更新，避免混淆。真正的 Sv39 PTE PPN 结构为：PPN[2](26bit) | PPN[1](9bit) | PPN[0](9bit) | Flags。实现中用统一的位屏蔽与移位来抽取地址部分。

#### 快速记忆
- 三层 9bit：`PDX1 / PDX0 / PTX`；
- 页内偏移 12bit：`PGOFF`；
- 一个最低层页表能映射 2MB；
- 权限组合快速使用宏，无需手写位；
- 低 10 位为标志，高位为物理页号。

# pmm.c的内容

### pte2page 和 pa2page 函数解析（pmm.h）

#### pte2page - 从页表项获取对应的 Page 结构体

```c
static inline struct Page *
pte2page(pte_t pte)
{
    if (!(pte & PTE_V))
    {
        panic("pte2page called with invalid pte");
    }
    return pa2page(PTE_ADDR(pte));
}
```

**功能**：从一个页表项（PTE）中提取物理页号，并返回对应的 `Page` 结构体指针。

**实现步骤**：
1. **有效性检查**：`!(pte & PTE_V)` 检查 PTE 的 Valid 位
   - 如果 PTE 无效（V=0），说明该页表项未映射，调用会导致 panic
   - 确保不会访问无效的物理页

2. **提取物理地址**：`PTE_ADDR(pte)` 
   - 清除低 10 位标志位，提取 PPN 字段
   - 左移 2 位对齐到物理地址（补齐页内偏移的 12 位）
   - 得到 4KB 对齐的物理页基址

3. **转换为 Page 结构体**：`pa2page(物理地址)`
   - 调用 `pa2page` 将物理地址转换为 `Page` 结构体指针


---

#### pa2page - 从物理地址获取对应的 Page 结构体

```c
static inline struct Page *
pa2page(uintptr_t pa)
{
    if (PPN(pa) >= npage)
    {
        panic("pa2page called with invalid pa");
    }
    return &pages[PPN(pa) - nbase];
}
```

**功能**：将物理地址转换为管理该物理页的 `Page` 结构体指针。

**实现详解**：

1. **提取物理页号**：`PPN(pa)` = `pa >> 12`
   - 去掉低 12 位页内偏移
   - 得到物理页号（Physical Page Number）

2. **边界检查**：`PPN(pa) >= npage`
   - `npage` 是系统管理的总页数
   - 防止访问超出物理内存范围的地址

3. **计算 Page 数组索引**：`PPN(pa) - nbase`
   - `nbase = DRAM_BASE / PGSIZE`，在 RISC-V 中通常 `DRAM_BASE = 0x80000000`
   - 因此 `nbase = 0x80000000 / 4096 = 0x80000`
   - 物理内存从 0x80000000 开始，对应的 `pages` 数组从索引 0 开始
   - 所以需要减去 `nbase` 来得到正确的数组索引

4. **返回指针**：`&pages[索引]`
   - `pages` 是全局数组，存储所有物理页的 `Page` 结构体
   - 返回对应物理页的 `Page` 结构体地址

**关键常量**：
- `pages`：全局 `struct Page` 数组，每个物理页对应一个元素
- `npage`：系统管理的物理页总数
- `nbase`：物理内存起始地址对应的页号（RISC-V 中为 0x80000）

**示例计算**：
```
物理地址 pa = 0x80001000
PPN(pa) = 0x80001000 >> 12 = 0x80001
数组索引 = 0x80001 - 0x80000 = 1
返回 &pages[1]
```

---

#### 两者关系与调用链

```
页表项(PTE) 
    ↓ pte2page
物理地址(PA) = PTE_ADDR(pte)
    ↓ pa2page
Page结构体指针 = &pages[PPN(pa) - nbase]
```

**核心思想**：
- **PTE → PA**：页表项存储的是物理页号（PPN），通过位操作提取并转换为物理地址
- **PA → Page**：物理地址映射到 `pages` 数组中的对应元素，该元素存储该物理页的元数据（引用计数、标志位等）

## nr_free_pages() 函数

```c
size_t nr_free_pages(void)
{
    size_t ret;
    bool intr_flag;
    local_intr_save(intr_flag);  // 保存中断状态并关闭中断
    {
        ret = pmm_manager->nr_free_pages();  // 调用物理内存管理器的方法
    }
    local_intr_restore(intr_flag);  // 恢复中断状态
    return ret;
}
```

**功能**：返回当前系统中空闲物理页的数量。

**实现要点**：
1. **中断保护**：使用 `local_intr_save` 和 `local_intr_restore` 保证操作的原子性
   - 防止在统计空闲页数时被中断打断
   - 避免并发访问导致的计数不一致
   
2. **委托给 PMM**：实际工作由 `pmm_manager->nr_free_pages()` 完成
   - `pmm_manager` 是物理内存管理器实例（如 first_fit、best_fit、buddy_system 等）
   - 不同的内存分配算法有各自的空闲页链表管理方式
   
3. **返回值**：空闲页数量（size_t 类型），可用于：
   - 检测内存泄漏（测试前后空闲页数是否一致）
   - 判断是否有足够内存进行分配
   - 系统监控与调试

**使用场景**：
- `check_pgdir()` 等测试函数中保存初始空闲页数，最后对比检查是否泄漏
- 内存分配前检查可用内存是否充足

## check_pgdir() 函数解析

该函数用于测试页表操作的正确性，包括页表项的插入、查询、权限设置和引用计数等。

### 函数完整代码与解释

```c
static void check_pgdir(void)
{
    size_t nr_free_store;
    nr_free_store = nr_free_pages();
    // 保存当前空闲页数量，用于最后检查是否有内存泄漏
```

#### 1. 基本检查
```c
    assert(npage <= KERNTOP / PGSIZE);
    assert(boot_pgdir_va != NULL && (uint32_t)PGOFF(boot_pgdir_va) == 0);
    // 确保页目录表存在且按页对齐（低12位为0）
    
    assert(get_page(boot_pgdir_va, 0x0, NULL) == NULL);
    // 虚拟地址0x0处应该没有映射
```

#### 2. 测试页表插入与查询
```c
    struct Page *p1, *p2;
    p1 = alloc_page();
    assert(page_insert(boot_pgdir_va, p1, 0x0, 0) == 0);
    // 将物理页p1映射到虚拟地址0x0，权限为0（仅内核可访问，只读）
```

**关键操作**：`page_insert` 会：
- 调用 `get_pte` 获取/创建对应的页表项
- 如有必要，自动分配中间层页表（三级页表结构）
- 设置页表项内容：PPN + 权限位
- 增加物理页的引用计数

```c
    pte_t *ptep;
    assert((ptep = get_pte(boot_pgdir_va, 0x0, 0)) != NULL);
    // 获取虚拟地址0x0对应的页表项指针（不创建新页表）
    
    assert(pte2page(*ptep) == p1);
    // 验证该页表项指向的物理页确实是p1
    
    assert(page_ref(p1) == 1);
    // p1的引用计数应为1
```

#### 3. 验证页表项地址计算
```c
    ptep = (pte_t *)KADDR(PDE_ADDR(boot_pgdir_va[0]));
    // boot_pgdir_va[0] 是一级页目录项，指向二级页表
    // PDE_ADDR 提取其物理地址，KADDR 转为内核虚拟地址
    
    ptep = (pte_t *)KADDR(PDE_ADDR(ptep[0])) + 1;
    // ptep[0] 是二级页目录项，指向三级页表
    // +1 得到三级页表中索引为1的项
    
    assert(get_pte(boot_pgdir_va, PGSIZE, 0) == ptep);
    // 虚拟地址 PGSIZE(4096) 对应的页表项应该就是上面计算出的 ptep
    // 因为 PGSIZE 的 PDX1=0, PDX0=0, PTX=1
```

**知识点**：手工遍历三级页表结构验证 `get_pte` 的正确性。

#### 4. 测试用户权限位传播
```c
    p2 = alloc_page();
    assert(page_insert(boot_pgdir_va, p2, PGSIZE, PTE_U | PTE_W) == 0);
    // 映射p2到虚拟地址PGSIZE，设置用户可访问(U)和可写(W)权限
    
    assert((ptep = get_pte(boot_pgdir_va, PGSIZE, 0)) != NULL);
    assert(*ptep & PTE_U);
    assert(*ptep & PTE_W);
    // 验证页表项包含正确的权限位
    
    assert(boot_pgdir_va[0] & PTE_U);
    // 重要：验证一级页目录项也被设置了PTE_U位
    // 这是因为RISC-V要求权限位在整条路径上传播
```

**知识点**：Sv39 要求从根页表到叶子页表的整条路径都要有 `PTE_U` 位，否则用户态无法访问。

```c
    assert(page_ref(p2) == 1);
    // p2的引用计数为1
```

#### 5. 测试页面替换与引用计数
```c
    assert(page_insert(boot_pgdir_va, p1, PGSIZE, 0) == 0);
    // 将虚拟地址PGSIZE重新映射到p1（覆盖原来的p2映射）
    
    assert(page_ref(p1) == 2);
    // p1现在被两个虚拟地址映射（0x0 和 PGSIZE），引用计数为2
    
    assert(page_ref(p2) == 0);
    // p2被自动释放，引用计数归0
    
    assert((ptep = get_pte(boot_pgdir_va, PGSIZE, 0)) != NULL);
    assert(pte2page(*ptep) == p1);
    // 验证PGSIZE现在映射到p1
    
    assert((*ptep & PTE_U) == 0);
    // 新的映射权限为0，不包含PTE_U位
```

**知识点**：`page_insert` 会自动处理旧映射的释放，正确维护引用计数。

#### 6. 测试页面移除
```c
    page_remove(boot_pgdir_va, 0x0);
    // 移除虚拟地址0x0的映射
    assert(page_ref(p1) == 1);
    // p1引用计数减1
    assert(page_ref(p2) == 0);
    
    page_remove(boot_pgdir_va, PGSIZE);
    // 移除虚拟地址PGSIZE的映射
    assert(page_ref(p1) == 0);
    // p1引用计数归0，物理页被自动释放
    assert(page_ref(p2) == 0);
```

#### 7. 清理中间页表并检查内存泄漏
```c
    assert(page_ref(pde2page(boot_pgdir_va[0])) == 1);
    // 一级页表项指向的二级页表页面引用计数为1
    
    pde_t *pd1 = boot_pgdir_va, *pd0 = page2kva(pde2page(boot_pgdir_va[0]));
    // pd1: 一级页表，pd0: 二级页表
    
    free_page(pde2page(pd0[0]));
    // 释放三级页表页面
    free_page(pde2page(pd1[0]));
    // 释放二级页表页面
    
    boot_pgdir_va[0] = 0;
    // 清空一级页表第0项
    flush_tlb();
    // 刷新TLB
    
    assert(nr_free_store == nr_free_pages());
    // 验证空闲页数量恢复，无内存泄漏
    
    cprintf("check_pgdir() succeeded!\n");
}
```

### 核心知识点总结

1. **三级页表遍历**：虚拟地址 → 一级页表 → 二级页表 → 三级页表 → 物理页
2. **权限位传播**：用户态访问需要整条路径的 `PTE_U` 位都设置
3. **引用计数管理**：多个虚拟地址可映射同一物理页，通过引用计数自动释放
4. **页表自动分配**：`page_insert`/`get_pte` 自动创建缺失的中间层页表
5. **TLB 一致性**：修改页表后必须刷新 TLB（通过 `sfence.vma` 指令）


