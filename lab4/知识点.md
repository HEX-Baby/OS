# sv39复习


### 3级页表结构

| Page Directory | Page Directory | Page Table     | Offset within Page |
|:--------------:|:--------------:|:--------------:|:------------------:|
| Index 1        | Index 2        |                |                    |
| PDX1(la)       | PDX0(la)       | PTX(la)        | PGOFF(la)          |
|                |                |                |                    |
| <-------------------PPN(la)------------------->                    |


### 虚拟地址结构

|  VPN[2]  |  VPN[1]  |  VPN[0]  |  PGOFF  |
|:--------:|:--------:|:--------:|:-------:|
|   9 bit  |   9 bit  |   9 bit  | 12 bit  |


### 物理地址结构

|  PPN[2]  |  PPN[1]  |  PPN[0]  |  PGOFF  |
|:--------:|:--------:|:--------:|:-------:|
|  26 bit  |   9 bit  |   9 bit  | 12 bit  |


### 页表项结构

|  PPN[2]  |  PPN[1]  |  PPN[0]  | Reserved | D | A | G | U | X | W | R | V |
|:--------:|:--------:|:--------:|:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  26 bit  |   9 bit  |   9 bit  |   2 bit  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

# kern/mm/mmu.h内容
下面结合源码逐条解释：

#### 地址分解与宏
sv39 的 64 位虚拟地址低 39 位参与页表（9+9+9+12），对应 `PDX1`(VPN[2])、`PDX0`(VPN[1])、`PTX`(VPN[0])、`PGOFF`。`mmu.h` 中：

- `#define PDX1(la) ((((uintptr_t)(la)) >> PDX1SHIFT) & 0x1FF)` 取最高层 9bit；
- `#define PDX0(la) ((((uintptr_t)(la)) >> PDX0SHIFT) & 0x1FF)` 取中间层 9bit；
- `#define PTX(la)  ((((uintptr_t)(la)) >> PTXSHIFT)  & 0x1FF)` 取最低层页表索引 9bit；
- `#define PGOFF(la) (((uintptr_t)(la)) & 0xFFF)` 页内偏移 12bit；
- `#define PPN(la)   (((uintptr_t)(la)) >> PTXSHIFT)` 去掉页内偏移后得到线性地址对应的“页号”字段（含所有 VPN bits 合起来）。一共**44**位

位移常量：

- `PTXSHIFT = 12` 页内偏移长度；
- `PDX0SHIFT = 21` = 12 + 9；
- `PDX1SHIFT = 30` = 12 + 9 + 9。

构造地址：`PGADDR(d1,d0,t,o)` 把三个层级索引与页内偏移重新拼成线性地址。
```cpp
#define PGADDR(d1, d0, t, o) ((uintptr_t)((d1) << PDX1SHIFT |(d0) << PDX0SHIFT | (t) << PTXSHIFT | (o)))
```
一个一个左移相应的位数，然后按位或拼接起来

#### 页表项地址抽取
```cpp
#define PTE_ADDR(pte)   (((uintptr_t)(pte) & ~0x3FF) << (PTXSHIFT - PTE_PPN_SHIFT))
#define PDE_ADDR(pde)   PTE_ADDR(pde)
```
- `PTE_ADDR(pte)` 清掉低 10 位标志位（`& ~0x3FF`），再左移把 PPN 对齐，得到物理页基址。把Reserved和DAG什么的全部删掉，然后左移12位**凑出了12位**的页内偏移。
- `PDE_ADDR(pde)` 与 `PTE_ADDR` 相同，用于目录项。

`PTE_PPN_SHIFT = 10` 表示 PTE 中低 10 位是标志，后面开始为 PPN。

在该页表示一个物理页的时候就有用。

#### 结构和大小常量
- `NPDEENTRY = 512`，`NPTEENTRY = 512`：每层 512 项（9bit）。
- `PGSIZE = 4096`，`PGSHIFT = 12`：页大小与其 log2。
- `PTSIZE = PGSIZE * NPTEENTRY = 2MB`：一个二级页表（最低层）映射的总字节数。
- `PTSHIFT = 21`：log2(2MB)。

#### 权限与标志位（对应 RISC-V PTE）
| 宏 | 值 | 说明 |
|----|----|------|
| `PTE_V` | 0x001 | 有效（Valid）|
| `PTE_R` | 0x002 | 可读 |
| `PTE_W` | 0x004 | 可写 |
| `PTE_X` | 0x008 | 可执行 |
| `PTE_U` | 0x010 | 用户态可访问 |
| `PTE_G` | 0x020 | 全局页（不清 TLB）|
| `PTE_A` | 0x040 | 已访问（硬件或软件置位）|
| `PTE_D` | 0x080 | 已修改（脏页）|
| `PTE_SOFT` | 0x300 | 软件保留位（实现可自定义）|

组合宏：
```cpp
#define PAGE_TABLE_DIR (PTE_V)
#define READ_ONLY (PTE_R | PTE_V)   // 只读
#define READ_WRITE (PTE_R | PTE_W | PTE_V)  //读写
#define EXEC_ONLY (PTE_X | PTE_V)   //只能执行
#define READ_EXEC (PTE_R | PTE_X | PTE_V)   //读 + 执行
#define READ_WRITE_EXEC (PTE_R | PTE_W | PTE_X | PTE_V) // 读写执行
```
- `PAGE_TABLE_DIR`：仅有效位，用来指示该条目指向下一层页表（一般还需要检查其余位是否为 0 来判定非叶子）。
- `READ_ONLY / READ_WRITE / EXEC_ONLY / READ_EXEC / READ_WRITE_EXEC`：常用权限集合，方便建立段/页映射。
- `PTE_USER`：用户页的常用组合（读写执行 + 用户 + 有效）。

#### 关于注释中 Sv32 的提醒
文件顶部和中间的 ASCII 注释仍显示 10/10/12 结构以及 “Sv32 page table entry”，这是旧的双级页表（Sv32）格式。当前宏与常量（512 项、9bit 索引、3 级）对应的是 Sv39。应注意该注释尚未更新，避免混淆。真正的 Sv39 PTE PPN 结构为：PPN[2](26bit) | PPN[1](9bit) | PPN[0](9bit) | Flags。实现中用统一的位屏蔽与移位来抽取地址部分。

#### 快速记忆
- 三层 9bit：`PDX1 / PDX0 / PTX`；
- 页内偏移 12bit：`PGOFF`；
- 一个最低层页表能映射 2MB；
- 权限组合快速使用宏，无需手写位；
- 低 10 位为标志，高位为物理页号。


