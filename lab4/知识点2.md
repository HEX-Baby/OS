# proc.h

## 进程控制块（PCB）- struct proc_struct

进程控制块（Process Control Block, PCB）是操作系统用来描述和管理进程的核心数据结构，包含了进程运行所需的全部状态信息。

```c
struct proc_struct
{
    enum proc_state state;        // Process state
    int pid;                      // Process ID
    int runs;                     // the running times of Proces
    uintptr_t kstack;             // Process kernel stack
    volatile bool need_resched;   // bool value: need to be rescheduled to release CPU?
    struct proc_struct *parent;   // the parent process
    struct mm_struct *mm;         // Process's memory management field
    struct context context;       // Switch here to run process
    struct trapframe *tf;         // Trap frame for current interrupt
    uintptr_t pgdir;              // the base addr of Page Directroy Table(PDT)
    uint32_t flags;               // Process flag
    char name[PROC_NAME_LEN + 1]; // Process name
    list_entry_t list_link;       // Process link list
    list_entry_t hash_link;       // Process hash list
};
```

### 字段详解

#### 1. 进程标识与状态

**`enum proc_state state`** - 进程状态
```c
enum proc_state
{
    PROC_UNINIT = 0,  // 未初始化
    PROC_SLEEPING,    // 睡眠（等待某个事件）
    PROC_RUNNABLE,    // 就绪/运行（在就绪队列或正在CPU上运行）
    PROC_ZOMBIE,      // 僵尸状态（进程已结束，等待父进程回收资源）
};
```
- **PROC_UNINIT**：进程刚分配，尚未完成初始化
- **PROC_SLEEPING**：阻塞状态，等待 I/O 或其他事件
- **PROC_RUNNABLE**：可运行状态，包括：
  - 在就绪队列中等待调度
  - 正在 CPU 上执行
- **PROC_ZOMBIE**：进程已退出，但父进程还未回收其资源（类似 Unix 僵尸进程）

**`int pid`** - 进程标识符
- 系统中唯一的进程 ID
- 范围：0 ~ MAX_PID（默认 `MAX_PID = MAX_PROCESS * 2 = 8192`）
- `pid = 0` 通常保留给 idle 进程

**`int runs`** - 运行次数
- 记录该进程被调度运行的次数
- 用于统计和调度算法（如时间片轮转）

---

#### 2. 内存管理相关

**`uintptr_t kstack`** - 内核栈地址
- 指向该进程的内核栈基址
- 内核栈用于：
  - 处理系统调用时的栈空间
  - 中断处理时的栈空间
  - 保存进程切换时的上下文
- 每个进程有独立的内核栈（通常 2 页，8KB）

**`uintptr_t pgdir`** - 页目录表基址
- 指向该进程的一级页表（页目录）的**物理地址**
- 进程切换时会将此地址写入 `satp` 寄存器，切换虚拟地址空间
- 内核线程共享内核页表，用户进程有独立页表

**`struct mm_struct *mm`** - 内存管理结构
- 指向进程的虚拟内存管理结构（Virtual Memory Area）
- 包含：
  - 代码段、数据段、堆、栈等虚拟内存区域描述
  - 页表管理信息
- 内核线程的 `mm` 为 NULL（只使用内核地址空间）

**mm_struct 结构详解**（定义在 vmm.h）：
```c
struct mm_struct {
    list_entry_t mmap_list;        // VMA 链表头，按起始地址排序
    struct vma_struct *mmap_cache; // 最近访问的 VMA，加速查找
    pde_t *pgdir;                  // 该进程的页目录表基址
    int map_count;                 // VMA 的数量
    void *sm_priv;                 // 页面置换算法的私有数据
};
```
- `mmap_list`：管理该进程所有虚拟内存区域（VMA）的链表
- `mmap_cache`：缓存最近访问的 VMA，提高查找效率
- `pgdir`：指向该进程的页目录表（与 `proc_struct->pgdir` 一致）
- `map_count`：该进程有多少个 VMA
- `sm_priv`：用于页面置换算法（如 FIFO、LRU）的私有数据

**VMA（虚拟内存区域）**：
```c
struct vma_struct {
    struct mm_struct *vm_mm;  // 所属的 mm_struct
    uintptr_t vm_start;       // VMA 起始地址（包含）
    uintptr_t vm_end;         // VMA 结束地址（不包含）
    uint32_t vm_flags;        // 权限标志（VM_READ/VM_WRITE/VM_EXEC）
    list_entry_t list_link;   // 链表节点
};
```
- 每个 VMA 描述一段连续的虚拟地址范围及其属性
- 例如：代码段（只读可执行）、数据段（可读写）、堆、栈等

---

#### 3. 调度与上下文切换

**`volatile bool need_resched`** - 重新调度标志
- `volatile` 表示该变量可能被中断处理程序修改，防止编译器优化
- `true`：需要让出 CPU，触发进程调度
- `false`：继续运行当前进程
- 时钟中断时可能设置此标志，实现时间片轮转

**`struct context context`** - 进程上下文
```c
struct context
{
    uintptr_t ra;   // return address (返回地址)
    uintptr_t sp;   // stack pointer (栈指针)
    uintptr_t s0;   // saved registers s0-s11 (被调用者保存寄存器)
    uintptr_t s1;
    // ... s2 ~ s11
};
```
- 保存进程切换时需要恢复的寄存器
- **RISC-V 调用约定**：
  - `ra`：函数返回地址
  - `sp`：栈指针
  - `s0-s11`：被调用者保存寄存器（Callee-saved）
- 进程切换流程：
  1. 保存当前进程的 `context`
  2. 恢复目标进程的 `context`
  3. 跳转到目标进程的 `ra` 地址继续执行

**`struct trapframe *tf`** - 中断帧指针
- 指向保存在内核栈上的 `trapframe` 结构
- 包含进程被中断时的**完整 CPU 状态**：
  - 32 个通用寄存器（x0-x31）
  - `pc`（程序计数器）
  - `sstatus`（状态寄存器）
  - `stval`、`scause` 等
- 用途：
  - 从中断/系统调用返回时恢复现场
  - `fork` 时复制父进程状态给子进程
  - 内核可修改 `tf` 来改变进程返回用户态后的行为

---

#### 4. 进程关系与组织

**`struct proc_struct *parent`** - 父进程指针
- 指向创建该进程的父进程
- 用于：
  - 进程树的管理
  - 子进程退出时向父进程发送信号
  - 孤儿进程的处理（父进程退出，子进程重新指定父进程）

**`list_entry_t list_link`** - 进程链表节点
- 用于将进程串联到全局进程链表 `proc_list`
- 遍历所有进程时使用
- 通过 `le2proc(le, list_link)` 宏从链表节点还原 `proc_struct` 指针

**`list_entry_t hash_link`** - 进程哈希表节点
- 用于将进程串联到基于 PID 的哈希表
- 快速通过 PID 查找进程（`find_proc(pid)`）
- 提高查找效率（O(1) vs O(n)）

---

#### 5. 其他标志

**`uint32_t flags`** - 进程标志位
- 用于标记进程的特殊属性，如：
  - 进程类型（内核线程 vs 用户进程）
  - 调试标志
  - 权限标志
- 具体定义根据实现而定

**`char name[PROC_NAME_LEN + 1]`** - 进程名称
- 最多 15 个字符 + '\0' 结束符
- 用于调试和显示（如 `ps` 命令）
- 示例：`"idle"`、`"init"`

---

### 关键宏与全局变量

```c
#define le2proc(le, member) \
    to_struct((le), struct proc_struct, member)
```
- **功能**：从链表节点指针还原 `proc_struct` 指针
- **原理**：通过成员偏移量计算结构体首地址
- **用法**：
  ```c
  list_entry_t *le = proc_list.next;
  struct proc_struct *proc = le2proc(le, list_link);
  ```

**全局进程指针**：
```c
extern struct proc_struct *idleproc;   // idle 进程（PID=0）
extern struct proc_struct *initproc;   // init 进程（PID=1）
extern struct proc_struct *current;    // 当前正在运行的进程
```

**idle 进程（空闲进程）**：
- **PID = 0**，系统中优先级最低的特殊进程
- **作用**：当没有其他就绪进程时运行，占位作用
- **实现**：死循环检查 `need_resched`，有其他进程就绪时立即调度
- **节能**：可执行 `wfi`（Wait For Interrupt）指令让 CPU 进入低功耗状态
- **简化调度**：确保调度器总有进程可运行，`current` 指针永远有效

---

### PCB 的生命周期

1. **创建**：`alloc_proc()` 分配并初始化 PCB
2. **初始化**：设置 PID、内核栈、页表等
3. **就绪**：加入就绪队列，等待调度
4. **运行**：`proc_run()` 切换到该进程
5. **阻塞**：等待事件，状态变为 `PROC_SLEEPING`
6. **退出**：`do_exit()` 释放资源，变为 `PROC_ZOMBIE`
7. **回收**：父进程调用 `wait` 回收僵尸进程的 PCB

---

## 内核栈（Kernel Stack）详解

### 什么是内核栈？

内核栈是每个进程在**内核态运行**时使用的独立栈空间，与用户栈（用户态栈）分离。

### 为什么需要内核栈？

1. **安全隔离**：
   - 用户栈位于用户空间，不可信（可能被恶意修改）
   - 内核栈位于内核空间，只有内核态可访问，保护内核数据安全

2. **特权级切换**：
   - 从用户态进入内核态（系统调用/中断）时，不能继续使用用户栈
   - 必须切换到内核栈，保证内核函数调用的栈空间安全可靠

3. **独立性**：
   - 每个进程有独立的内核栈，避免内核态执行时的相互干扰
   - 支持多个进程在内核态的并发执行

### 内核栈的大小与位置

```c
#define KSTACKPAGE  2                           // 内核栈占用的页数
#define KSTACKSIZE  (KSTACKPAGE * PGSIZE)       // 内核栈大小 = 2 * 4KB = 8KB
```

- **大小**：通常 2 页（8KB），比用户栈小得多
- **位置**：在内核地址空间，通过 `proc_struct->kstack` 记录基址
- **布局**：从高地址向低地址增长（与大多数栈一致）

```
高地址 →  +------------------+  ← kstack + KSTACKSIZE (栈顶初始位置)
          |                  |
          |   内核栈空间     |  ← 向下增长
          |   (8KB)          |
          |                  |
低地址 →  +------------------+  ← kstack (栈基址)
```

### 内核栈的用途

#### 1. 保存中断/异常时的寄存器状态

当发生中断、异常或系统调用时：
1. 硬件自动将 `pc` 保存到 `sepc`
2. 软件将所有寄存器保存到内核栈上，形成 `trapframe`
3. 内核处理中断
4. 从 `trapframe` 恢复寄存器
5. 通过 `sret` 返回用户态

```c
// trapframe 保存在内核栈上
struct trapframe *tf = (struct trapframe *)(kstack + KSTACKSIZE - sizeof(struct trapframe));
```

#### 2. 提供系统调用的栈空间

- 用户程序调用 `read()` 等系统调用时，进入内核态
- 内核函数（如 `sys_read`）在内核栈上执行
- 函数调用链、局部变量都使用内核栈

#### 3. 保存进程切换的上下文

- `proc_struct->context` 保存在内核栈中
- `switch_to` 函数切换进程时，在内核栈上操作 `context`

#### 4. 内核函数调用

- 内核态执行期间的所有函数调用都使用内核栈
- 包括中断处理函数、调度器、内存管理等



### 栈切换流程示例

#### 系统调用时的栈切换：

```
1. 用户程序调用 read()
   用户栈: sp → [用户栈内容]
   
2. 执行 ecall 指令，进入内核态
   硬件切换: sp → 内核栈顶
   
3. 保存寄存器到内核栈（形成 trapframe）
   内核栈: sp → [trapframe] [内核函数栈帧]
   
4. 内核执行 sys_read()
   内核栈: sp → [sys_read 栈帧] [trapframe]
   
5. 返回用户态（sret）
   恢复 trapframe，sp 切换回用户栈
   
6. 用户程序继续执行
   用户栈: sp → [用户栈内容]
```

### 关键点

1. **每个进程独立**：每个进程都有自己的内核栈，避免内核态的数据混乱
2. **自动切换**：特权级切换时，硬件/软件协作自动完成栈切换
3. **大小有限**：内核栈只有 8KB，不能递归过深或分配大数组
4. **内核栈溢出**：如果内核函数调用链过深，可能导致栈溢出，覆盖相邻内存
5. **trapframe 位置**：通常放在内核栈的顶部（高地址），便于访问


# proc.c

## 全局变量

### 进程管理的核心全局变量

```c
// the process set's list
list_entry_t proc_list;
```
- **进程链表**：串联系统中所有进程的双向链表头
- 通过 `proc->list_link` 将进程加入此链表

```c
#define HASH_SHIFT 10
#define HASH_LIST_SIZE (1 << HASH_SHIFT)  // 1024
#define pid_hashfn(x) (hash32(x, HASH_SHIFT))

// has list for process set based on pid
static list_entry_t hash_list[HASH_LIST_SIZE];
```
- **PID 哈希表**：1024 个链表头组成的哈希表
- 用途：通过 PID 快速查找进程（`find_proc(pid)`）
- 哈希函数：`pid_hashfn(pid)` 将 PID 映射到 0~1023
- 通过 `proc->hash_link` 将进程加入对应的哈希桶

```c
// idle proc
struct proc_struct *idleproc = NULL;
```
- **idle 进程指针**：指向 PID=0 的空闲进程
- 系统启动时第一个创建，最低优先级
- 无其他就绪进程时运行，执行 `cpu_idle()` 死循环

```c
// init proc
struct proc_struct *initproc = NULL;
```
- **init 进程指针**：指向 PID=1 的第一个用户级进程
- 由 idle 进程通过 `kernel_thread` 创建
- 负责启动其他用户进程（类似 Linux 的 init）

```c
// current proc
struct proc_struct *current = NULL;
```
- **当前进程指针**：指向正在 CPU 上运行的进程
- 进程切换时更新：`current = next_proc`
- 内核代码通过 `current` 访问当前进程的 PCB

```c
static int nr_process = 0;
```
- **进程计数器**：记录系统中当前的进程总数
- 创建进程时 `nr_process++`，销毁时 `nr_process--`
- 用于限制进程数量（不超过 `MAX_PROCESS`）

---

### 数据结构关系图

```
proc_list (全局链表)
    ↓
[idle] ←→ [init] ←→ [proc1] ←→ [proc2] ←→ ...
  ↓         ↓         ↓         ↓
hash_list[0]: [idle]
hash_list[1]: [init]
hash_list[n]: [proc1] → [proc2]  (哈希冲突，链式解决)
  ...

current → [当前运行的进程]
idleproc → [idle]
initproc → [init]
```

---
