# 练习1

#### 代码补充：
```cpp
clock_set_next_event(); // (1) 设置下一次时钟中断
ticks++;                // (2) 计数器加一
if (ticks == TICK_NUM) 
{
    ticks = 0;
    print_ticks();      // (3) 输出100ticks
    print_counts++;     // (4) 打印次数加一
    if (print_counts == 10)
    {
        sbi_shutdown();     // 调用关机函数
    }
}
```
在开头，定义了一个全局变量`print_counts`, 还有一些riscv的宏，`ticks`是在`clock.h`中定义的;开头要有`#include<sbi.h>`，然后就可以调用`sbi_shutdown()`了
```cpp
// 为 riscv.h 中定义的宏创建别名
#define sscratch CSR_SSCRATCH
#define stvec    CSR_STVEC
// // 用于记录时钟中断的次数
// int ticks = 0;
// 用于记录 "100 ticks" 打印的行数
int print_counts = 0;
```

#### 运行结果

```
OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc0200054 (virtual)
  etext  0xffffffffc0201f14 (virtual)
  edata  0xffffffffc0206028 (virtual)
  end    0xffffffffc02064a0 (virtual)
Kernel executable memory footprint: 26KB
memory management: default_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0205000
satp physical address: 0x0000000080205000
++ setup timer interrupts
100 ticks       // 1
100 ticks       // 2
100 ticks       // 3
100 ticks       // 4
100 ticks       // 5
100 ticks       // 6
100 ticks       // 7
100 ticks       // 8
100 ticks       // 9
100 ticks       // 10
```
#### 实现过程和定时器中断中断处理的流程

从打印信息来分析这个流程
```
++ setup timer interrupts
```
1. `kern_init` 调用 `clock_init()` (位于 clock.c)。

2. `clock_init()` 内部打印 "++ setup timer interrupts"。

3. 它接着调用 `clock_set_next_event()` 来设置第一次时钟中断。

4. `紧接着，kern_init` 调用 `intr_enable()` (位于 intr.c)。这个函数打开了 CPU 的中断总开关。

5. 最后，`kern_init` 进入一个 `while(1)`; 死循环，等待中断的发生。


# 扩展练习 Challenge1：描述与理解中断流程

# 扩增练习 Challenge2：理解上下文切换机制

# 扩展练习Challenge3：完善异常中断

#### 代码补充
```cpp
case CAUSE_ILLEGAL_INSTRUCTION:
    // 非法指令异常处理
    /*(1)输出指令异常类型（ Illegal instruction）
    *(2)输出异常指令地址
    *(3)更新 tf->epc寄存器
    */
    cprintf("Illegal instruction caught at 0x%08x\n", tf->epc);
    cprintf("Exception type:Illegal instruction\n");
    tf->epc += 4; // 更新 tf->epc 寄存器

    break;
case CAUSE_BREAKPOINT:
    //断点异常处理
    /*(1)输出指令异常类型（ breakpoint）
    *(2)输出异常指令地址
    *(3)更新 tf->epc寄存器
    */
    cprintf("ebreak caught at 0x%08x\n", tf->epc);
    cprintf("Exception type: breakpoint\n");
    tf->epc += 4; // 更新 tf->epc 寄存器

    break;
```
