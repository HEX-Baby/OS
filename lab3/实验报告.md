# 练习1

#### 代码补充：
```cpp
clock_set_next_event(); // (1) 设置下一次时钟中断
ticks++;                // (2) 计数器加一
if (ticks == TICK_NUM) 
{
    ticks = 0;
    print_ticks();      // (3) 输出100ticks
    print_counts++;     // (4) 打印次数加一
    if (print_counts == 10)
    {
        sbi_shutdown();     // 调用关机函数
    }
}
```
在开头，定义了一个全局变量`print_counts`, 还有一些riscv的宏，`ticks`是在`clock.h`中定义的;开头要有`#include<sbi.h>`，然后就可以调用`sbi_shutdown()`了
```cpp
// 为 riscv.h 中定义的宏创建别名
#define sscratch CSR_SSCRATCH
#define stvec    CSR_STVEC
// // 用于记录时钟中断的次数
// int ticks = 0;
// 用于记录 "100 ticks" 打印的行数
int print_counts = 0;
```

#### 运行结果

```
OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc0200054 (virtual)
  etext  0xffffffffc0201f14 (virtual)
  edata  0xffffffffc0206028 (virtual)
  end    0xffffffffc02064a0 (virtual)
Kernel executable memory footprint: 26KB
memory management: default_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0205000
satp physical address: 0x0000000080205000
++ setup timer interrupts
100 ticks       // 1
100 ticks       // 2
100 ticks       // 3
100 ticks       // 4
100 ticks       // 5
100 ticks       // 6
100 ticks       // 7
100 ticks       // 8
100 ticks       // 9
100 ticks       // 10
```
#### 实现过程和定时器中断中断处理的流程

从打印信息来分析这个流程
```
++ setup timer interrupts
```
1. `kern_init` 调用 `clock_init()` (位于 clock.c)。

2. `clock_init()` 内部打印 "++ setup timer interrupts"。

3. 它接着调用 `clock_set_next_event()` 来设置第一次时钟中断。

4. `紧接着，kern_init` 调用 `intr_enable()` (位于 intr.c)。这个函数打开了 CPU 的中断总开关。

5. 最后，`kern_init` 进入一个 `while(1)`; 死循环，等待中断的发生。

```
              ┌──────────────────────────────────────────────────┐
              │ A. 正常执行                                      │
              │                                                  │
              │   A1: CPU 在 while(1) 空闲循环中执行               │
              │                                                  │
              └──────────────────────────────────────────────────┘
                                      │
                                      │ 中断发生
                                      ↓
              ┌──────────────────────────────────────────────────┐
              │ B. 硬件中断                                      │
              │                                                  │
              │   B1: 硬件时钟到达预设值                         │
              │      ↓                                           │
              │   B2: CPU 自动完成:                              │
              │       1. 保存当前 PC 到 sepc                     │
              │       2. 设置 scause 等 CSR                      │
              │       3. 跳转到 stvec 指向的地址 (__alltraps)    │
              │                                                  │
              └──────────────────────────────────────────────────┘
                                      │
                                      │ 控制权交给汇编
                                      ↓
              ┌──────────────────────────────────────────────────┐
              │ C. 汇编入口 (trapentry.S)                          │
              │                                                  │
              │   C1: 执行 __alltraps:                           │
              │      ↓                                           │
              │   C2: SAVE_ALL 宏:                               │
              │       1. 保存所有通用寄存器到栈上                │
              │       2. 保存 sstatus, sepc 等 CSR 到栈上        │
              │       ▶ 此时一个完整的 trapframe 在栈上构建完成  │
              │      ↓                                           │
              │   C3: 准备调用 C 函数:                           │
              │       1. 将栈指针 sp (即 trapframe 地址) 放入 a0 │
              │       2. jal trap                                │
              │                                                  │
              └──────────────────────────────────────────────────┘
                                      │
                                      │ 控制权交给 C
                                      ↓
              ┌──────────────────────────────────────────────────┐
              │ D. C语言处理 (trap.c)                              │
              │                                                  │
              │   D1: 执行 trap() 函数                           │
              │      ↓                                           │
              │   D2: trap_dispatch() 判断中断类型               │
              │      ↓                                           │
              │   D3: interrupt_handler() 处理具体中断           │
              │      ↓                                           │
              │   D4: case IRQ_S_TIMER:                           │
              │       1. ticks++                                 │
              │       2. 打印 '100 ticks'                        │
              │       3. 调用 clock_set_next_event()             │
              │       4. 判断是否关机                            │
              │      ↓                                           │
              │   D5: C 函数处理完毕，返回 (ret)                 │
              │                                                  │
              └──────────────────────────────────────────────────┘
                                      │
                                      │ 控制权还给汇编
                                      ↓
              ┌──────────────────────────────────────────────────┐
              │ E. 汇编返回 (trapentry.S)                          │
              │                                                  │
              │   E1: 从 jal trap 返回, 执行 __trapret:          │
              │      ↓                                           │
              │   E2: RESTORE_ALL 宏:                            │
              │       1. 从栈上的 trapframe 恢复 sstatus, sepc   │
              │       2. 恢复所有通用寄存器                      │
              │      ↓                                           │
              │   E3: 执行 sret 指令                             │
              │                                                  │
              └──────────────────────────────────────────────────┘
                                      │
                                      │ 控制权还给硬件
                                      ↓
              ┌──────────────────────────────────────────────────┐
              │ F. 返回正常执行                                  │
              │                                                  │
              │   F1: CPU 恢复到中断前的状态，                   │
              │       并从 sepc 指向的地址继续执行               │
              │       (回到 while(1) 循环)                      │
              │                                                  │
              └──────────────────────────────────────────────────┘
                                      │
                                      │ 等待下一次中断
                                      └─────────────────> (回到 B 阶段)

```


# 扩展练习 Challenge1：描述与理解中断流程
### 1. 描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？
**处理中断异常的流程：**<br>
1）异常产生：CPU 在执行指令时检测到异常、陷入或外部中断<br>
硬件自动保存现场到 CSR：<br>
  sepc ← 当前 PC（被中断的指令地址）<br>
  scause ← 中断/异常原因码<br>
  stval ← 附加信息（如出错地址）<br>
  sstatus ← 更新中断使能位等状态<br>
2）跳转到中断入口点<br>
根据 stvec 寄存器找到中断入口点 __alltraps<br>
3）保存完整上下文<br>
在__alltraps中，执行SAVE_ALL宏，将32个通用寄存器和4个控制状态寄存器保存到栈上<br>
4）调用中断处理函数trap<br>
执行完SAVE_ALL宏并传递sp后，跳转到trap，在trap中对各种中断（时钟中断、软件中断、定时中断、外部中断等）和异常（非法指令异常、断点异常等）进行处理<br>
5）恢复上下文并返回<br>
执行 __trapret 中的 RESTORE_ALL，sret 指令返回到被中断的程序<br>

**mov a0，sp的目的：**<br>
传递参数给 trap 函数，sp 此时指向栈上的 trapframe 结构，trap 函数需要这个参数来访问保存的寄存器值和 CSR 信息，从而分析中断原因、访问出错地址、修改返回地址等。
    
### 2. SAVE_ALL中寄存器保存在栈中的位置是什么确定的？
寄存器在栈中的位置由 结构体定义 和 汇编宏 共同确定；<br>
位置确定原则：<br>
通过 REGBYTES（8 字节）作为偏移量单位；<br>
严格按照 struct trapframe 的内存布局顺序存储；<br>
sp 寄存器的保存需要特殊处理（通过 sscratch）。<br>

### 3. 对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。
需要保存所有寄存器。理由如下：<br>
1）通用性设计：中断处理程序不知道具体是哪种中断，也无法预测哪些寄存器被使用，必须保守地保存所有状态。<br>
2）上下文完整性：为了能够正确返回到被中断的程序，必须完整保存所有通用寄存器的状态，确保恢复后程序能继续正常执行。<br>
3）嵌套中断处理：在处理一个中断时可能发生更高优先级的中断，完整的上下文保存支持中断嵌套。<br>
4）C 函数调用要求：调用 trap() C 函数时，C 编译器可能使用任何调用者保存的寄存器，会破坏原有值。<br>
# 扩增练习 Challenge2：理解上下文切换机制



## 问题1：在 `trapentry.S` 中，汇编代码 `csrw sscratch, sp` 和 `csrrw s0, sscratch, x0` 实现了什么操作，目的是？

### 相关代码分析

在 `kern/trap/trapentry.S` 的 `SAVE_ALL` 宏中：

```assembly
.macro SAVE_ALL
    # 第一步：将当前栈指针保存到 sscratch
    csrw sscratch, sp                    # 第5行
    
    addi sp, sp, -36 * REGBYTES
    # ... 保存通用寄存器 x0-x31 ...
    
    # 第二步：原子交换，取回原始 sp 并清零 sscratch
    csrrw s0, sscratch, x0               # 第44行
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, stval
    csrr s4, scause
    
    # 第三步：将保存的值存入栈帧
    STORE s0, 2*REGBYTES(sp)             # 保存原始 sp
    STORE s1, 32*REGBYTES(sp)            # 保存 sstatus
    STORE s2, 33*REGBYTES(sp)            # 保存 sepc
    STORE s3, 34*REGBYTES(sp)            # 保存 stval
    STORE s4, 35*REGBYTES(sp)            # 保存 scause
.endm
```

### 操作流程详解

#### 第一步：
    将当前栈指针 `sp` 的值写入 `sscratch` CSR，刚进入异常/中断时，`sp` 还是原始值，此举是临时保存原始栈指针

#### 第二步：
    读取 `sscratch` 的当前值（即原始 sp）→ 存入 `s0`，同时将 `x0` 的值（恒为 0）写入 `sscratch`


### 设计目的

这个设计有三重目的：

#### 1. 保存原始栈指针
在修改 `sp` 之前，先将其保存
通过 `s0` 最终存入栈帧的 `2*REGBYTES` 位置
这样在恢复上下文时可以恢复正确的 `sp` 值

#### 2. 标记内核态
将 `sscratch` 清零表示"当前正在内核态处理异常"
这是一个重要的状态标记

#### 3. 支持嵌套异常检测

如果在处理异常的过程中又发生了新的异常（递归异常/嵌套中断）异常处理程序可以通过检查 `sscratch` 是否为 0 来判断：`sscratch == 0`：异常来自内核态，`sscratch != 0`：异常来自用户态

### 图示说明

```
进入异常时：
┌──────────────────────────────────────┐
│ 1. csrw sscratch, sp                 │
│    sscratch ← 原始 sp                │
│    sp 仍然保持不变                    │
└──────────────────────────────────────┘
              ↓
┌──────────────────────────────────────┐
│ 2. addi sp, sp, -36*REGBYTES         │
│    调整栈指针，分配栈帧空间            │
└──────────────────────────────────────┘
              ↓
┌──────────────────────────────────────┐
│ 3. 保存所有通用寄存器 x0-x31          │
└──────────────────────────────────────┘
              ↓
┌──────────────────────────────────────┐
│ 4. csrrw s0, sscratch, x0            │
│    s0 ← sscratch (原始sp)            │
│    sscratch ← 0 (标记内核态)         │
└──────────────────────────────────────┘
              ↓
┌──────────────────────────────────────┐
│ 5. 保存 s0 到栈帧                     │
│    STORE s0, 2*REGBYTES(sp)          │
└──────────────────────────────────────┘
```

---

## 问题2：`SAVE_ALL` 里面保存了 `stval`、`scause` 这些 CSR，而在 `RESTORE_ALL` 里面却不还原它们，为什么？保存的意义何在？



### CSR 寄存器分类

保存的 CSR 可以分为两类：
    控制寄存器和信息寄存器


### 为什么不需要恢复？


    `scause` 和 `stval` 是硬件在发生异常时自动写入它们记录的是"为什么发生异常"和"哪里出了问题"在下一次异常发生时，硬件会自动更新它们的值，它们属于不需要恢复的只读寄存器
    当 `sret` 指令返回时，这些寄存器的值对程序的执行没有任何影响，它们只是历史记录，不是执行状态，CPU 不会读取这些寄存器来决定如何执行程序

    人为恢复旧值会造成混淆————如果在异常处理过程中又发生异常，旧值会误导调试，保持它们为最新值有助于调试


这种设计体现了操作系统的一个重要原则：

区分状态和信息
-状态需要保存和恢复，因为它影响程序的执行，信息只需要保存，因为它只用于诊断和处理决策


# 扩展练习Challenge3：完善异常中断

#### 代码补充
```cpp
case CAUSE_ILLEGAL_INSTRUCTION:
      // 非法指令异常处理
      /* LAB3 CHALLENGE3   2312991 :  */
    /*(1)输出指令异常类型（ Illegal instruction）
      *(2)输出异常指令地址
      *(3)更新 tf->epc寄存器
    */
    cprintf("Illegal instruction caught at 0x%08x\n", tf->epc);
    cprintf("Exception type:Illegal instruction\n");
    tf->epc += 4; // 更新 tf->epc 寄存器

    break;
case CAUSE_BREAKPOINT:
    //断点异常处理
    /* LAB3 CHALLLENGE3   2312991 :  */
    /*(1)输出指令异常类型（ breakpoint）
      *(2)输出异常指令地址
      *(3)更新 tf->epc寄存器
    */
    cprintf("ebreak caught at 0x%08x\n", tf->epc);
    cprintf("Exception type: breakpoint\n");

    // --- 开始: 判断并输出指令长度的代码 ---

    // 1. 定义一个变量来存储指令长度
    int length = 0;

    // 2. 从 epc 指向的内存地址读取前 16-bit (2字节) 的指令码
    //    需要将 uintptr_t 类型的 epc 强制转换为指针类型
    uint16_t instruction_word = *(uint16_t *)(tf->epc);

    // 3. 检查指令码的最低两位 (LSBs)
    //    0x3 在二进制中是 0b11
    if ((instruction_word & 0x3) == 0x3) {
        // 如果最低两位是 '11'，则是标准的 32-bit (4字节) 指令
        length = 4;
    } else {
        // 如果最低两位不是 '11' (即 00, 01, 10)，则是 16-bit (2字节) 压缩指令
        length = 2;
    }

    // 4. 使用 cprintf 输出指令长度
    cprintf("Instruction Length: %d bytes\n", length);

    // 5. 根据计算出的长度来更新 epc
    tf->epc += length;
    
    // --- 结束: 判断并输出指令长度的代码 --

    break;
```
断点指令ebreak的指令长度是2字节，所以在`case CAUSE_BREAKPOINT`中，需要更新`tf->epc`寄存器的值为`tf->epc + 2`，以跳过这条指令。这个2字节真有点坑人。


然后在inic.c中补充
```cpp
cprintf("+++ Now triggering a breakpoint exception! +++\n");
__asm__ volatile("ebreak");
cprintf("+++ Breakpoint exception handled, execution continues. +++\n");

cprintf("+++ Now triggering an illegal instruction exception! +++\n");
__asm__ volatile("mret");
cprintf("+++ Illegal instruction handled, execution continues. +++\n");
```

#### 结果


```
++ setup timer interrupts
+++ Now triggering a breakpoint exception! +++
ebreak caught at 0xc02000a8
Exception type: breakpoint
Instruction Length: 2 bytes
+++ Breakpoint exception handled, execution continues. +++
+++ Now triggering an illegal instruction exception! +++
sbi_emulate_csr_read: hartid0: invalid csr_num=0x302
Illegal instruction caught at 0xc02000c2
Exception type:Illegal instruction
+++ Illegal instruction handled, execution continues. +++
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
```
上面是一样的，然后在`++ setup timer interrupts`之后就输出了捕捉到异常的信息和断点捕捉信息，printf出来发现ebreak确实是2字节的。

```
ebreak caught at 0xc02000a8
Exception type: breakpoint
Instruction Length: 2 bytes

Illegal instruction caught at 0xc02000a8
Exception type:Illegal instruction
```
这一段是在`trap.c`文件中的 `exception_handler()` 函数输出

```
+++ Now triggering a breakpoint exception! +++
+++ Breakpoint exception handled, execution continues. +++

+++ Illegal instruction handled, execution continues. +++
+++ Now triggering an illegal instruction exception! +++
```
这一段是在`init.c `中输出的

#分工

陈培杰完成练习1和challenge3，邵雯丽完成challenge1，吕影焜完成challenge2

