### 知识前提

中断前后需要**恢复上下文环境**，用一个名为**中断帧**（TrapFrame）的**结构体**存储了要保存的各寄存器

### 中断分类

1. **异常(Exception)**

    - 执行一条指令的过程中发生了错误。
    - 访问无效内存地址、执行非法指令(除零)、缺页等。


2. **陷入(Trap)**

    - 主动通过一条指令停下来.
    - 通过`ecall`进行系统调用(syscall)，或通过`ebreak`进入断点(breakpoint)。

3. **外部中断(Interrupt)**
    - CPU 的执行过程被**外设**发来的信号打断
    - 定时器倒计时结束、串口收到数据等。

### 外部中断是同步还是异步的？

- **异步**

### 中断程序处于什么态？

- 内核态

### 中断处理调用什么模式？

大多数在 `S` 模式下， `M` 模式的异常处理程序也可以通过**异常委托机制**选择性地将中断和同步异常直接交给 `S` 模式处理。

RISCV中 **默认情况**下所有异常都会先进入 `M` 模式，然后再根据配置决定是否交给 `S` 模式处理


### CSRs

控制状态寄存器

### 怎么禁止 CPU 产生中断？

`sstatus`寄存器 里面有一个二进制位 `SIE`(1 << 1), 数值为`0`的时候，如果当程序在`S`态运行，将**禁用全部中断**。

    为什么“对于在U态运行的程序，SIE这个二进制位的数值没有任何意义”？

    当 CPU 运行在 U 模式时，它 **根本没有权限处理中断**。

`sstatus` 还有一个二进制位`UIE`(user interrupt enable)可以在置零的时候禁止用户态程序产生中断(就是不会陷入)。


### 中断处理程序在哪？

`stvec` , 中断向量表基址, 把不同种类的**中断**映射到对应的**中断处理程序**。

`stvec`会把最低位的两个二进制位用来编码一个`“模式”:`

- `00:` 62 位 存储 唯一的中断处理程序的地址

- `01:` 62 位 存储 中断向量表基址，通过不同的异常原因来索引中断向量表

较高的62位后补两个0, 凑成 64 位。


### 触发中断进入 S 态进行处理时， 哪些寄存器会被硬件自动设置，将一些信息提供给中断处理程序？

- `sepc:` 记录触发中断的那条指令的**地址**
- `scause:` 记录中断发生的**原因**，还记录该中断是不是一个外部中断
- `stval:` 记录一些中断处理所需要的**辅助信息**, 比如指令获取(instruction fetch)、访存、缺页异常 **(中断类型)** ，它会把发生问题的**目标地址**或者出错的**指令**记录下来，这样我们在中断处理程序中就知道处理目标了。 

### RISCV 支持的 和中断相关的特权指令

- `ecall:` S 状态执行 就会 进入 M 模式。 U 状态执行 就会 进入 S 模式。


- `sret:` 从 S 状态返回 U 状态。

- `ebreak:` 执行这条指令会触发一个断点中断从而进入中断处理流程。

- `mret:` 从 M 状态返回 U 状态 或者 S 状态。


### 一个trapFrame结构体占据的空间？

在 `trap.h` 定义这个结构体

36个`uintptr_t`, `uintptr_t` 为64位无符号整数


### trapFrame 剩下4个字段的含义，注意epc 和 badvaddr的区别
| 字段         | 含义               | 对应 RISC-V 寄存器 |
| ---------- | ---------------- | ------------- |
| `status`   | 保存当时的 CPU 状态     | `sstatus`     |
| `epc`      | 异常前的 PC（出错的指令地址） | `sepc`        |
| `badvaddr` | 出错的虚拟地址          | `stval`       |
| `cause`    | 异常原因（中断号或异常号）    | `scause`      |


### 保存/恢复 上下文（所有寄存器）

在 `trapentry.S` 中定义了

#### 保存：汇编宏 `SAVE_ALL`

```
.macro SAVE_ALL #定义汇编宏
```
`.macro`定义；`.endm`结束

```
csrw sscratch, sp #保存原先的栈顶指针到sscratch
```

```
addi sp, sp, -36 * REGBYTES 
#REGBYTES是riscv.h定义的常量，表示一个寄存器占据几个字节
#让栈顶指针向低地址空间延伸 36个寄存器的空间，可以放下一个trapFrame结构体。
#除了32个通用寄存器，我们还要保存4个和中断有关的CSR
```

RISCV不能直接从CSR写到内存, 需要csrr把CSR读取到通用寄存器，再从通用寄存器STORE到内存。
```
csrrw s0, sscratch, x0
csrr s1, sstatus
csrr s2, sepc
csrr s3, sbadaddr
csrr s4, scause

STORE s0, 2*REGBYTES(sp)
STORE s1, 32*REGBYTES(sp)
STORE s2, 33*REGBYTES(sp)
STORE s3, 34*REGBYTES(sp)
STORE s4, 35*REGBYTES(sp)
```
这里选择的是，依次读入s0 - s4。

**三个易混淆的 指令**
| 指令          | 英文全称                 | 功能描述              |
| ----------- | -------------------- | ----------------- |
| **`csrr`**  | *CSR Read*           | 从 CSR 读取一个值到通用寄存器 |
| **`csrw`**  | *CSR Write*          | 将通用寄存器的值写入 CSR    |
| **`csrrw`** | *CSR Read and Write* | 同时读取 CSR 的旧值并写入新值 |

| 指令                   | 操作数格式                     | 作用 |
| -------------------- | ------------------------- | -- |
| `csrr rd, csr`       | 读取 CSR → 通用寄存器            |    |
| `csrw csr, rs1`      | 写通用寄存器 → CSR              |    |
| `csrrw rd, csr, rs1` | 交换：读 CSR → rd，写 rs1 → CSR |    |

#### 恢复：汇编宏 `RESTORE_ALL`
先弄出这两个寄存器：
```
LOAD s1, 32*REGBYTES(sp)
LOAD s2, 33*REGBYTES(sp)

csrw sstatus, s1
csrw sepc, s2
```
然后是通用寄存器
最后是SP
```
LOAD x2, 2*REGBYTES(sp)
```

#### 为什么不是所有的CSR都要恢复？

必须恢复的有
| CSR            | 原因                                           |
| -------------- | -------------------------------------------- |
| `sstatus`      | 包含中断开关（SIE）与返回模式（SPP），trap handler 可能修改，需要恢复 |
| `sepc`         | trap 返回地址（执行 `sret` 会自动跳转到此），可能修改            |
| （可选）`sscratch` | 用作保存栈指针的中间寄存器（一般软件使用）                        |

不是必须的有

| CSR                               | 原因                              |
| --------------------------------- | ------------------------------- |
| `scause` / `sbadaddr`             | 仅用于 trap handler 诊断原因，返回用户态时无意义 |
| `stvec`                           | 通常在初始化时设定 trap 向量入口地址，不会改变      |
| `satp`                            | 控制页表基址，trap handler 一般不改        |
| `sie` / `sip`                     | 中断使能/挂起寄存器，在内核里管理，不随 trap 栈帧变化  |
| `time` / `cycle` 等                | 读写不会影响恢复现场                      |
| `medeleg` / `mideleg` / `mtvec` 等 | 属于机器级（M-mode）CSR，S 模式 trap 不涉及  |

实际上就是**用完就丢，留着也没用**

### 中断入口点是什么？
`__alltraps`

**作用**是保存和恢复上下文，并把上下文包装成结构体送到trap函数那里去。



在这之前有，`.align(2)` 4字节对齐。


1. `SAVE_ALL` 
    保存上下文

2. `move  a0, sp` 
    a0寄存器传递参数给接下来调用的函数trap。
3. `jal trap`
    跳转
4. `__trapret:`
    这个执行了`RESTORE_ALL`来恢复上下文，然后`sret`返回到用户态。

### 有一个点非常疑惑，为什么在init.c中要两次idt_init();

？？？？？

### idt_init() 详解
这个在`trap.c`文件定义。
```cpp
void idt_init(void) {
    extern uintptr_t __vectors[];
    extern void __alltraps(void);
    write_csr(sscratch, 0);
    write_csr(stvec, &__alltraps);
}
```

这里实际上只执行了2行代码。第一个把`sscratch`寄存器清理，这个是一个临时寄存器，相当于临时变量；第二个把`stvec`初始化为`__alltraps`的地址，这就是对应汇编代码`trapentry.S`中的中断入口点。

进入`.S`文件之后就跳转到了`trap`函数，但是`trap`函数在`trap.c`文件

所以这是一个**反复横跳**。

```cpp
entry.S --> init.c ---(idt_init();)---> trap.c 
---(write_csr(stvec, &__alltraps);)---> 假设有中断的话
------> trapentry.S ---(__alltraps)---(trap())---> trap.c
```

### trap.c 
在函数`interrupt_handler()`
```
intptr_t cause = (tf->cause << 1) >> 1; 
//抹掉scause最高位代表“这是中断不是异常”的1
```

### clock.c 详解

#### get_cycles()

在`clock.c`, 顺带提一下函数`get_cycles()`

**作用**：这个函数读取机器的高精度周期计数器。

- 64位版本 (`#if __riscv_xlen == 64`):
 在 64 位 CPU 上，实现很简单。rdtime %0 这条汇编指令直接将 64 位的 time CSR 读入变量 n。

- 32位版本 (`#else`): 在 32 位 CPU 上，无法用一条指令读取一个 64 位的寄存器。这段代码使用了一种标准的、安全的方法来完成这个操作：

    `rdtimeh %0:` 读取时钟的高 32 位。

    `rdtime %1:` 读取低 32 位。

    `rdtimeh %2:` 再次读取高 32 位。

    `bne %0, %2, 1b`: 比较两次读取的高位值。如果它们不相同，意味着在读取低 32 位的过程中，它发生了翻转（溢出）。如果发生这种情况，代码会跳转回起始位置（1b 是一个局部标签）并重新尝试读取。


`rdtime`伪指令，读取一个叫做`time`的CSR的数值，表示CPU启动之后经过的真实时间
#### clock_init()

然后是`clock_init()`

```cpp
void clock_init(void) {
    set_csr(sie, MIP_STIP);
    clock_set_next_event();
    ticks = 0;

    cprintf("++ setup timer interrupts\n");
}
```
1. `set_csr(sie, MIP_STIP):` 这行代码在 S-mode (Supervisor level) 启用时钟中断。

    - `sie` 代表 监管者中断使能 (Supervisor Interrupt Enable)。

    - `MIP_STIP` 是 监管者时钟中断挂起 (Supervisor Timer Interrupt Pending) 的位掩码。在 sie 寄存器中设置这一位，允许 CPU 在 S-mode 下接收时钟中断。

2. `clock_set_next_event()`: 这个调用会安排第一次时钟中断。

3. `ticks = 0`: 将全局节拍计数器初始化为 0。

**作用**：设置了一个中断闹钟

#### clock_set_next_event()

```cpp
void clock_set_next_event(void) { sbi_set_timer(get_cycles() + timebase); }
```
这个函数用于**安排下一次时钟中断**, 就是订个闹钟。

这里的 `timebase` 被硬编码为 `100000` 个时钟周期。

这个**流程**就是


```cpp
init.c[调用clock_init()] ------> clock.c[调用clock_set_next_event()]

------> 设置了一个闹钟，第100000之后产生一次中断
```

#### sbi_set_timer()

再次套娃

```cpp
void sbi_set_timer(unsigned long long stime_value) {
    sbi_call(SBI_SET_TIMER, stime_value, 0, 0);
}
```
#### sbi_call()

```cpp
uint64_t sbi_call(uint64_t sbi_type, uint64_t arg0, uint64_t arg1, uint64_t arg2) 
{
    uint64_t ret_val;
    __asm__ volatile (
        ///将功能编号（比如 SBI_SET_TIMER）放入 a7 寄存器 (x17)。M-mode 固件会检查这个寄存器，以确定内核想做什么。
        "mv x17, %[sbi_type]\n" 
        
        // 将第一个参数（对于 sbi_set_timer 来说，就是下一次中断的目标时间 stime_value）放入 a0 寄存器 (x10)。
        "mv x10, %[arg0]\n"
        "mv x11, %[arg1]\n"
        "mv x12, %[arg2]\n"

        //执行这条指令。CPU 会暂停 S-mode 的内核，切换到 M-mode，并跳转到 M-mode 固件预设好的代码地址。
        "ecall\n"

//1.  M-mode 工作: M-mode 固件的代码接管控制权。它读取 a7 和 a0 寄存器的值，然后操作物理硬件来设置时钟。

//2.  返回: M-mode 完成任务后，会执行 mret 指令返回到 S-mode，内核从 ecall 的下一条指令继续执行。返回值会按约定放在 a0 寄存器中。

        //将 a0 寄存器中的返回值存入 C 语言变量 ret_val。
        "mv %[ret_val], x10"
        : [ret_val] "=r" (ret_val)
        : [sbi_type] "r" (sbi_type), [arg0] "r" (arg0), [arg1] "r" (arg1), [arg2] "r" (arg2)
        : "memory"
    );
    return ret_val;
}
```

### intr.c 详解

```cpp
/* intr_enable - enable irq interrupt */
void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); }

/* intr_disable - disable irq interrupt */
void intr_disable(void) { clear_csr(sstatus, SSTATUS_SIE); }
```
设置了`sstatus`寄存器

`SIE` 位是` S-mode` (内核模式) 的全局中断总开关。当它被设置为 `1 `时，CPU 才允许响应任何已使能的中断请求（如时钟中断、外部设备中断等）。


`intr_enable` 将其设置为1， `intr_disable` 将其设置为0

### sync.h

```c
static inline bool __intr_save(void) 
{
    if (read_csr(sstatus) & SSTATUS_SIE) { // 1. 检查中断总开关 (SIE) 是否打开
        intr_disable();                    // 2. 如果是打开的，就关闭它
        return 1;                          // 3. 返回 1，表示“是我关的”
    }
    return 0;                              // 4. 如果本来就是关的，什么都不做，返回 0
}
```
```c
static inline void __intr_restore(bool flag) 
{
    if (flag) {                            // 1. 检查标志位
        intr_enable();                     // 2. 如果标志为 true，才重新打开中断
    }
}
```

```c
#define local_intr_save(x) \
    do {                   \
        x = __intr_save(); \
    } while (0)

调用 __intr_save() 并将其返回值（0 或 1）保存在变量 x 中。

#define local_intr_restore(x) __intr_restore(x);
调用 __intr_restore()，并传入之前保存的状态 x 来恢复中断。
```

这两个是宏，提供了更方便的用户接口。

`do-while(0)` 是一种 C 语言的常用技巧，它能确保宏在任何情况下（比如在没有花括号的 if 语句后）都能被当作一条独立的、完整的语句来执行，从而避免语法错误。就是末尾可以吃掉一个分号`;`。


这套机制的正确用法如下，它能完美处理**嵌套临界区**的场景。
```c
bool flag; // 用于保存中断状态的“钥匙”

local_intr_save(flag); // 进入临界区：保存当前中断状态，然后确保中断关闭

// --- Critical Section Start ---
//
// 这里的代码绝对不会被任何中断打扰
// 可以安全地操作共享数据
//
// ---  Critical Section End  ---

local_intr_restore(flag); // 离开临界区：根据保存的状态，智能地恢复中断
```

想象一下函数 A 调用了函数 B，它们都需要临界区：
```c
void func_B() {
    bool flag_B;
    local_intr_save(flag_B); // 此时中断已关闭，flag_B 被设为 0
    // ... B 的临界区 ...
    local_intr_restore(flag_B); // 因为 flag_B 是 0，这里不会错误地打开中断
}

void func_A() {
    bool flag_A;
    local_intr_save(flag_A); // 假设中断本来是开的，这里会关闭它，flag_A 被设为 1
    // ... A 的临界区 ...
    func_B(); // 调用 B
    // ... A 的临界区 ...
    local_intr_restore(flag_A); // 因为 flag_A 是 1，这里会负责把中断恢复为开启状态
}
```
这个设计保证了只有最外层的 `local_intr_save` 会真正关闭中断，也只有它对应的 `local_intr_restore` 会最终恢复中断，避免了内层函数错误地破坏外层函数的临界区。

比如说 在分配和释放内存的过程中，我们会先关闭中断，然后进行对应操作，最后重新开启中断，就是指导书对应的那段代码：
```c
// kern/mm/pmm.c
struct Page *alloc_pages(size_t n) {
    struct Page *page = NULL;
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        page = pmm_manager->alloc_pages(n);
    }
    local_intr_restore(intr_flag);
    return page;
}

// free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory
void free_pages(struct Page *base, size_t n) {
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        pmm_manager->free_pages(base, n);
    }
    local_intr_restore(intr_flag);
}
```