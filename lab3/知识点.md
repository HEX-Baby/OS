### 知识前提

中断前后需要**恢复上下文环境**，用一个名为**中断帧**（TrapFrame）的**结构体**存储了要保存的各寄存器

### 中断分类

1. **异常(Exception)**

    - 执行一条指令的过程中发生了错误。
    - 访问无效内存地址、执行非法指令(除零)、缺页等。


2. **陷入(Trap)**

    - 主动通过一条指令停下来.
    - 通过`ecall`进行系统调用(syscall)，或通过`ebreak`进入断点(breakpoint)。

3. **外部中断(Interrupt)**
    - CPU 的执行过程被**外设**发来的信号打断
    - 定时器倒计时结束、串口收到数据等。

### 外部中断是同步还是异步的？

- **异步**

### 中断程序处于什么态？

- 内核态

### 中断处理调用什么模式？

大多数在 `S` 模式下， `M` 模式的异常处理程序也可以通过**异常委托机制**选择性地将中断和同步异常直接交给 `S` 模式处理。

RISCV中 **默认情况**下所有异常都会先进入 `M` 模式，然后再根据配置决定是否交给 `S` 模式处理


### CSRs

控制状态寄存器

### 怎么禁止 CPU 产生中断？

`sstatus`寄存器 里面有一个二进制位 `SIE`(1 << 1), 数值为`0`的时候，如果当程序在`S`态运行，将**禁用全部中断**。

    为什么“对于在U态运行的程序，SIE这个二进制位的数值没有任何意义”？

    当 CPU 运行在 U 模式时，它 **根本没有权限处理中断**。

`sstatus` 还有一个二进制位`UIE`(user interrupt enable)可以在置零的时候禁止用户态程序产生中断(就是不会陷入)。


### 中断处理程序在哪？

`stvec` , 中断向量表基址, 把不同种类的**中断**映射到对应的**中断处理程序**。

`stvec`会把最低位的两个二进制位用来编码一个`“模式”:`

- `00:` 62 位 存储 唯一的中断处理程序的地址

- `01:` 62 位 存储 中断向量表基址，通过不同的异常原因来索引中断向量表

较高的62位后补两个0, 凑成 64 位。


### 触发中断进入 S 态进行处理时， 哪些寄存器会被硬件自动设置，将一些信息提供给中断处理程序？

- `sepc:` 记录触发中断的那条指令的**地址**
- `scause:` 记录中断发生的**原因**，还记录该中断是不是一个外部中断
- `stval:` 记录一些中断处理所需要的**辅助信息**, 比如指令获取(instruction fetch)、访存、缺页异常 **(中断类型)** ，它会把发生问题的**目标地址**或者出错的**指令**记录下来，这样我们在中断处理程序中就知道处理目标了。 

### RISCV 支持的 和中断相关的特权指令

- `ecall:` S 状态执行 就会 进入 M 模式。 U 状态执行 就会 进入 S 模式。


- `sret:` 从 S 状态返回 U 状态。

- `ebreak:` 执行这条指令会触发一个断点中断从而进入中断处理流程。

- `mret:` 从 M 状态返回 U 状态 或者 S 状态。


### 一个trapFrame结构体占据的空间？

在 `trap.h` 定义这个结构体

36个`uintptr_t`, `uintptr_t` 为64位无符号整数


### trapFrame 剩下4个字段的含义，注意epc 和 badvaddr的区别
| 字段         | 含义               | 对应 RISC-V 寄存器 |
| ---------- | ---------------- | ------------- |
| `status`   | 保存当时的 CPU 状态     | `sstatus`     |
| `epc`      | 异常前的 PC（出错的指令地址） | `sepc`        |
| `badvaddr` | 出错的虚拟地址          | `stval`       |
| `cause`    | 异常原因（中断号或异常号）    | `scause`      |


### 保存/恢复 上下文（所有寄存器）

在 `trapentry.S` 中定义了

#### 保存：汇编宏 `SAVE_ALL`

```
.macro SAVE_ALL #定义汇编宏
```
`.macro`定义；`.endm`结束

```
csrw sscratch, sp #保存原先的栈顶指针到sscratch
```

```
addi sp, sp, -36 * REGBYTES 
#REGBYTES是riscv.h定义的常量，表示一个寄存器占据几个字节
#让栈顶指针向低地址空间延伸 36个寄存器的空间，可以放下一个trapFrame结构体。
#除了32个通用寄存器，我们还要保存4个和中断有关的CSR
```

RISCV不能直接从CSR写到内存, 需要csrr把CSR读取到通用寄存器，再从通用寄存器STORE到内存。
```
csrrw s0, sscratch, x0
csrr s1, sstatus
csrr s2, sepc
csrr s3, sbadaddr
csrr s4, scause

STORE s0, 2*REGBYTES(sp)
STORE s1, 32*REGBYTES(sp)
STORE s2, 33*REGBYTES(sp)
STORE s3, 34*REGBYTES(sp)
STORE s4, 35*REGBYTES(sp)
```
这里选择的是，依次读入s0 - s4。

**三个易混淆的 指令**
| 指令          | 英文全称                 | 功能描述              |
| ----------- | -------------------- | ----------------- |
| **`csrr`**  | *CSR Read*           | 从 CSR 读取一个值到通用寄存器 |
| **`csrw`**  | *CSR Write*          | 将通用寄存器的值写入 CSR    |
| **`csrrw`** | *CSR Read and Write* | 同时读取 CSR 的旧值并写入新值 |

| 指令                   | 操作数格式                     | 作用 |
| -------------------- | ------------------------- | -- |
| `csrr rd, csr`       | 读取 CSR → 通用寄存器            |    |
| `csrw csr, rs1`      | 写通用寄存器 → CSR              |    |
| `csrrw rd, csr, rs1` | 交换：读 CSR → rd，写 rs1 → CSR |    |

#### 恢复：汇编宏 `RESTORE_ALL`
先弄出这两个寄存器：
```
LOAD s1, 32*REGBYTES(sp)
LOAD s2, 33*REGBYTES(sp)

csrw sstatus, s1
csrw sepc, s2
```
然后是通用寄存器
最后是SP
```
LOAD x2, 2*REGBYTES(sp)
```

#### 为什么不是所有的CSR都要恢复？

必须恢复的有
| CSR            | 原因                                           |
| -------------- | -------------------------------------------- |
| `sstatus`      | 包含中断开关（SIE）与返回模式（SPP），trap handler 可能修改，需要恢复 |
| `sepc`         | trap 返回地址（执行 `sret` 会自动跳转到此），可能修改            |
| （可选）`sscratch` | 用作保存栈指针的中间寄存器（一般软件使用）                        |

不是必须的有

| CSR                               | 原因                              |
| --------------------------------- | ------------------------------- |
| `scause` / `sbadaddr`             | 仅用于 trap handler 诊断原因，返回用户态时无意义 |
| `stvec`                           | 通常在初始化时设定 trap 向量入口地址，不会改变      |
| `satp`                            | 控制页表基址，trap handler 一般不改        |
| `sie` / `sip`                     | 中断使能/挂起寄存器，在内核里管理，不随 trap 栈帧变化  |
| `time` / `cycle` 等                | 读写不会影响恢复现场                      |
| `medeleg` / `mideleg` / `mtvec` 等 | 属于机器级（M-mode）CSR，S 模式 trap 不涉及  |

实际上就是**用完就丢，留着也没用**

### 中断入口点是什么？
`__alltraps`

**作用**是保存和恢复上下文，并把上下文包装成结构体送到trap函数那里去。



在这之前有，`.align(2)` 4字节对齐。


1. `SAVE_ALL` 
    保存上下文

2. `move  a0, sp` 
    a0寄存器传递参数给接下来调用的函数trap。
3. `jal trap`
    跳转
4. `__trapret:`
    这个执行了`RESTORE_ALL`来恢复上下文，然后`sret`返回到用户态。

### 有一个点非常疑惑，为什么在init.c中要两次idt_init();

？？？？？

### idt_init() 详解
这个在`trap.c`文件定义。
```cpp
void idt_init(void) {
    extern uintptr_t __vectors[];
    extern void __alltraps(void);
    write_csr(sscratch, 0);
    write_csr(stvec, &__alltraps);
}
```

这里实际上只执行了2行代码。第一个把`sscratch`寄存器清理，这个是一个临时寄存器，相当于临时变量；第二个把`stvec`初始化为`__alltraps`的地址，这就是对应汇编代码`trapentry.S`中的中断入口点。

进入`.S`文件之后就跳转到了`trap`函数，但是`trap`函数在`trap.c`文件

所以这是一个**反复横跳**。

```cpp
entry.S --> init.c ---(idt_init();)---> trap.c 
---(write_csr(stvec, &__alltraps);)---> 假设有中断的话
------> trapentry.S ---(__alltraps)---(trap())---> trap.c
```


### clock_init() 详解

在`clock.c`, 顺带提一下函数`get_cycles()`

**作用**：这个函数读取机器的高精度周期计数器。

- 64位版本 (`#if __riscv_xlen == 64`):
 在 64 位 CPU 上，实现很简单。rdtime %0 这条汇编指令直接将 64 位的 time CSR 读入变量 n。

- 32位版本 (`#else`): 在 32 位 CPU 上，无法用一条指令读取一个 64 位的寄存器。这段代码使用了一种标准的、安全的方法来完成这个操作：

    `rdtimeh %0:` 读取时钟的高 32 位。

    `rdtime %1:` 读取低 32 位。

    `rdtimeh %2:` 再次读取高 32 位。

    `bne %0, %2, 1b`: 比较两次读取的高位值。如果它们不相同，意味着在读取低 32 位的过程中，它发生了翻转（溢出）。如果发生这种情况，代码会跳转回起始位置（1b 是一个局部标签）并重新尝试读取。

然后是`clock_init()`

```cpp
void clock_init(void) {
    set_csr(sie, MIP_STIP);
    clock_set_next_event();
    ticks = 0;

    cprintf("++ setup timer interrupts\n");
}
```
1. `set_csr(sie, MIP_STIP):` 这行代码在 S-mode (Supervisor level) 启用时钟中断。

    - `sie` 代表 监管者中断使能 (Supervisor Interrupt Enable)。

    - `MIP_STIP` 是 监管者时钟中断挂起 (Supervisor Timer Interrupt Pending) 的位掩码。在 sie 寄存器中设置这一位，允许 CPU 在 S-mode 下接收时钟中断。

2. `clock_set_next_event()`: 这个调用会安排第一次时钟中断。

3. `ticks = 0`: 将全局节拍计数器初始化为 0。


```cpp
void clock_set_next_event(void) { sbi_set_timer(get_cycles() + timebase); }
```
这个函数用于**安排下一次时钟中断**

### intr_enable() 详解


