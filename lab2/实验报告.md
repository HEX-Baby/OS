# 练习1

分析函数这4个函数前，先列举2个常用的结构体
```cpp
typedef struct {
    list_entry_t free_list;         // the list header
    unsigned int nr_free;           // number of free pages in this free list
} free_area_t;
struct Page {
    int ref;                        // page frame's reference counter
    uint64_t flags;                 // array of flags that describe the status of the page frame
    unsigned int property;          // the num of free block, used in first fit pm manager
    list_entry_t page_link;         // free list link
};
```
在`default_pmm.c`中, `free_list`和`nr_free`分别被设置为`free_area_t`的成员变量的宏定义，起始就是拿出来了,作为全局变量，一个是链表头，一个是空闲块的数量。

这里有一个缺陷就是只有一个双链表来维护，这样的话很多不同大小的块就会放在一个链表里面，导致查找的时候效率低下。

`Page`结构体中，`ref`是引用计数器，`flags`是描述页帧状态的数组，`property`是空闲块的数量，`page_link`是空闲链表的链接。

得到的地址空间图类似于：
```
虚拟地址 (VA)                                         物理地址 (PA)
高地址 ^                                                 高地址 ^
      |                                                        |
      +-----------------------------------------+              +-----------------------------------------+
      |                                         |              |  物理内存最高地址                       |
      +-----------------------------------------+              +-----------------------------------------+
      | (可能的内存碎片, 大小不足一页)          |              
      +=========================================+ <--- mem_end (向下对齐, 可用内存的物理上界)
      |                                         |
      |                                         |
      |    这部分物理内存由 free_list 管理      |
      |    (初始状态为一个巨大的空闲块)         |
      |                                         |
      +=========================================+ <--- mem_begin (向上对齐, 可用内存的物理下界)
      | (可能的对齐“空隙”, 被舍弃)             |
      +-----------------------------------------+ <--- freemem (紧跟在 pages 数组之后, 未对齐)
      |                                         |
      |      pages 数组 (物理内存的“账本”)      |
      |                                         |
      +-----------------------------------------+
      |                                         |
      +------------------.----------------------+
      | KERNBASE + ...   `end` 符号 (虚拟地址)  |
      |                  +----------------------+
      | 内核镜像         | .bss 段              |
      | (Kernel Image)   +----------------------+
      |                  | .data/.sdata 段      |
      | 已被占用         +----------------------+
      |                  | .rodata 段           |
      |                  +----------------------+
      |                  | .text 段 (代码)      |
      +------------------'----------------------+
      | KERNBASE (0xFFFFFFFFC0200000)          | <----------> | 内核加载的物理基地址 (如 0x80200000)
      +-----------------------------------------+              +-----------------------------------------+
      |                                         |              | (OpenSBI 固件区域)                      |
      |                                         |              +-----------------------------------------+
      |                                         |              | DRAM_BASE (物理内存起点, 0x80000000)    |
低地址 v                                                 低地址 v
```

一个重要的对应关系，混淆了很久
```cpp
+------------------+      通过 pa2page(物理地址) 计算索引      +-----------------------+
| pages 数组       | --------------------------------------> | 物理内存页 (所有)      |
| (管理者)         | <-------------------------------------- | (被管理的对象)         |
+------------------+        查询/修改 Page 结构体状态          +-----------------------+
```

展开来就是
```cpp
pages 数组 (管理元数据)                        物理内存 (实际RAM)
          (存放在某个物理地址)                           (从 0x80000000 开始)
     +-----------------------------+
     | ...                         |
     +-----------------------------+                  +----------------------------+
     | Page 结构 for pa(i-1)       |                  | ...                        |
     +-----------------------------+                  +----------------------------+
     | Page 结构 for pa(i)         | <--- base 指针   |                            | <--- mem_begin (物理地址)
     +-----------------------------+      指向这里      +----------------------------+
     | Page 结构 for pa(i+1)       | <--- base + 1    |                            | <--- mem_begin + PGSIZE
     +-----------------------------+      指向这里      +----------------------------+
     | Page 结构 for pa(i+2)       | <--- base + 2    |                            | <--- mem_begin + 2*PGSIZE
     +-----------------------------+      指向这里      +----------------------------+
     | ...                         |                  | ...                        |
     | (连续的 n 个 Page 结构)     |                  | (连续的 n 个物理页)        |
     | ...                         |                  | ...                        |
     +-----------------------------+                  +----------------------------+
     | Page 结构 for pa(i+n-1)     | <--- base + n-1  |                            | <--- mem_begin + (n-1)*PGSIZE
     +-----------------------------+      指向这里      +----------------------------+
     | ...                         |                  | ...                        |
     +-----------------------------+                  +----------------------------+
```

### default_init()
```cpp
static inline void list_init(list_entry_t *elm) {
    elm->prev = elm->next = elm;
}

static void default_init(void) {
    list_init(&free_list);
    nr_free = 0;
}
```
作用是“创建账本”。这是 PMM 的第一个动作，负责创建并初始化一个空的 `free_area_t `管理结构。

调用 `list_init(&free_list)`来初始化全局的双向链表头，使其 `next` 和 `prev` 指针都指向自己，形成一个空的循环链表。

设置` nr_free = 0`，将全局空闲页总数清零。

### default_init_memmap()
这个函数是由`pmm.c`中的`page_init()`使用
```cpp
if (freemem < mem_end) {
        init_memmap(pa2page(mem_begin), (mem_end - mem_begin) / PGSIZE);
    }
```
函数头是这样的：
```cpp
static void default_init_memmap(struct Page *base, size_t n) 
```
和在一起看就是在`base`地址处初始化`n`个页，并将其加入到空闲链表中，这里使用的base就是`pa2page(mem_begin)`。

**作用就是：** 在 `page_init()` 确定了内核本身和 `pages` 数组占用的空间后，会把剩余的所有可用物理内存作为一个巨大的初始块，调用此函数将其“注册”到 PMM 中。

#### 具体流程

- **准备页：** 遍历从 `base(pa2page(mem_begin))` 开始的 `n` 个 `Page` 结构体，清空它们的 `flags` 和 `ref` 计数，确保它们处于干净状态。
```cpp
struct Page *p = base;
for (; p != base + n; p ++) {
        assert(PageReserved(p));
        p->flags = p->property = 0;
        set_page_ref(p, 0);
}
```

- **标记首页**：设置首页 `base->property = n`，记录下这个巨大空闲块的总大小。同时设置 `base` 的 `PG_property` 标志位，正式声明它是一个空闲块的“代表”。
```cpp
base->property = n;
```

- **更新总数：** `nr_free += n`，将这 n 个页加入到全局空闲页总数中。
```cpp
nr_free += n;
```

- **插入链表**：将 `base` 的 `page_link` 节点插入到全局的 `free_list` 中。为了方便后续的合并操作，插入时必须保持链表按物理地址从低到高排序。


PMM 的 free_list 中现在有了一个（或多个）节点，代表着大块的初始空闲内存。nr_free 也更新为系统初始的可用页总数。至此，初始化完成。

### default_alloc_pages()
初始化完成后，内核通过调用 `alloc_pages` 和 `free_pages` 来动态管理内存。

**作用：** 按需分配。这是向 PMM 申请 n 个连续物理页的核心函数。

#### 具体流程

- **快速检查：** 首先检查请求的 n 是否大于总空闲页数 `nr_free`，如果大于，则直接返回 `NULL。`
```cpp
if (n > nr_free) {return NULL;}
```
- **首次适应查找**：从 `free_list` 的头部开始，依次遍历每一个空闲块（由其首页代表）。
```cpp
list_entry_t *le = &free_list;
while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n) {
            page = p;
            break;
        }
    }
```

- **检查大小：** 对于每个块 p，检查 `p->property >= n` 是否成立。

- **找到与分割：** 一旦找到第一个满足条件的块 p，就停止搜索 `-->` 将 p 从 `free_list` 中移除 `-->` 如果 p->property > n（找到的块比需要的大），则执行分割操作:
```cpp
if (page->property > n) {
    struct Page *p = page + n;
    p->property = page->property - n;
    SetPageProperty(p);
    list_add(prev, &(p->page_link));
}
```

- **更新与返回：** `nr_free -= n`，更新全局空闲页总数。清除被分配出去的首页 p 的 PG_property 标志，因为它不再是空闲块了。返回首页指针 p，如果没找到就返回`NULL`。


### default_free_pages()

**作用：** 将一块不再使用的内存归还给 PMM。

#### 具体流程

- **准备与标记** ：将被释放的 n 个页的状态重置（清 flags，ref=0），并将首页 `base` 的 `property` 设为 n，标记为新的空闲块。在代码中就是一个for循环
```cpp
struct Page *p = base;
for (; p != base + n; p ++) {
    assert(!PageReserved(p) && !PageProperty(p));
    p->flags = 0;
    set_page_ref(p, 0);
}
```
- **插入链表：** 像 `default_init_memmap` 一样，将 `base` 插入到 `free_list` 中，保持地址有序。并更新总数：nr_free += n。

- **合并** ：这是最关键的一步，为了防止内存碎片化。
这里有两种，先向前合并，然后向后合并，这里的检查比较简单，只是检查地址是否连续，如果连续就合并。具体到代码中就是：
```cpp
list_entry_t* le = list_prev(&(base->page_link)); //前向合并
......
p = le2page(le, page_link);
if (p + p->property == base)
......

le = list_next(&(base->page_link)); //后向合并
......
p = le2page(le, page_link);
if (base + base->property == p)
......
```

结果就是释放的内存被重新纳入管理，并尽可能地与已有的空闲块合并，形成更大的连续空闲区。

`make qemu`之后
```c
PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc02000d6 (virtual)
  etext  0xffffffffc0201716 (virtual)
  edata  0xffffffffc0206018 (virtual)
  end    0xffffffffc0206078 (virtual)
Kernel executable memory footprint: 24KB
memory management: default_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0205000
satp physical address: 0x0000000080205000
```

内核占用了24KB。

物理内存探测结果：
```
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
```
起点是0x0000000008000000，范围是 [0x0000000080000000, 0x0000000087ffffff]

三级页表（boot_page_table_sv39）地址
```
satp virtual address: 0xffffffffc0205000
satp physical address: 0x0000000080205000
```

--------------------------------
# 练习2:实现best_fit

结果
```c
PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc02000d6 (virtual)
  etext  0xffffffffc0201656 (virtual)
  edata  0xffffffffc0205018 (virtual)
  end    0xffffffffc0205078 (virtual)
Kernel executable memory footprint: 20KB
memory management: best_fit_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0204000
satp physical address: 0x0000000080204000
```
最后显示check_alloc_page() succeeded!应该就是成功了。

修改的地方其实不多，大部分逻辑和`first_fit`差不多，主要的区别还是分配内存的函数的逻辑不一样，其实理解了`first_fit`的代码，写`best_fit`就很简单。

**分配内存的函数修改部分**
```cpp
    int best_n = -1;
    struct Page *best_page = NULL;


    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n) 
        {
            if(best_n == -1 || best_n > p->property)
            {
                best_n = p->property;
                best_page = p;
            }
        }
    }
    page = best_page;
```
当时写的时候没有注意到代码里面已经给了`min_size`变量，不过无伤大雅，我自己定义一个`best_n`变量来记录最适合的空闲块的大小，然后在循环里面找到最适合的空闲块，并更新`best_page`。初始化`best_n = -1 `是用来标记是否分配了一个。然后就是从前往后依次遍历，时间复杂度固定是`O(n)`,n是指总的空闲页数。

每次循环，如果找到一个满足的，看看是否可以更小，如果是更小的话，就更新`best_page` 和 `best_n`。

代码中和 `first_fit` 不一样的地方就上面，其他都是一样的，管理空闲链也是只用了一个链表。

best_fit 我想过优化，其实这里的瓶颈是在于查找最佳空闲块的那个循环。可以转化为平衡树来查找，但是，实现起来就比较麻烦，插入和删除比较简单，就是释放之后，合并空闲页的时候会不好合并，比如说我们平衡树中的Node是这样定义的话：
```cpp
struct Node
{
    Page *page;
    Node *left, *right;
}
```
查找的时候根据page->property来查找。但是在合并的时候会有困难，比如说要和前面的空闲块合并，我得先在平衡树里面找到这个页，可是这里平衡树查找是根据property，而不是页号，因此就很难在平衡树里面找到这个页并将其删除来进行合并。

如果优化这个策略的话，可以采用下面的那些策略。毕竟只是在一个策略里面绕弯子不如换一个策略来实现更简单。

--------------------------------


# 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）





--------------------------------



# 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）





--------------------------------




# 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）


























